297. Serialize and Deserialize Binary Tree
```
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

For example, you may serialize the following tree

    1
   / \
  2   3
     / \
    4   5
as "[1,2,3,null,null,4,5]", just the same as how LeetCode OJ serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.

 

Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.

Credits:
Special thanks to @Louis1992 for adding this problem and creating all test cases.
```

my thoughts:
```
1. use two heaps to store the first and second half of the input.
Time: add() -> O(lgn); findMedian() -> O(1)
```

my solution:
```
********** 
class MedianFinder:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.h1 = []
        self.h2 = []

    def addNum(self, num):
        """
        :type num: int
        :rtype: void
        """
        if not self.h1:
            heapq.heappush(self.h1, -num)
            return
        if not self.h2:
            if num < -self.h1[0]:
                self.h2.append(-self.h1.pop())
                self.h1.append(-num)
            else:
                self.h2.append(num)
            return
        if num <= self.h2[0] and num >= -self.h1[0]:
            if len(self.h1) > len(self.h2):
                heapq.heappush(self.h2, num)
            else:
                heapq.heappush(self.h1, -num)
        elif num > self.h2[0]:
            if len(self.h1) > len(self.h2):
                heapq.heappush(self.h2, num)
            else:
                temp = heapq.heapreplace(self.h2, num)
                heapq.heappush(self.h1, -temp)
        else:
            if len(self.h1) > len(self.h2):
                temp = heapq.heapreplace(self.h1, -num)
                heapq.heappush(self.h2, -temp)
            else:
                heapq.heappush(self.h1, -num)
                
        #print(self.h1, self.h2)
        
    def findMedian(self):
        """
        :rtype: float
        """
        if not self.h1:
            return 0.0
        if len(self.h1) == len(self.h2):
            return (-self.h1[0] + self.h2[0]) / 2
        else:
            return float(-self.h1[0])


# Your MedianFinder object will be instantiated and called as such:
# obj = MedianFinder()
# obj.addNum(num)
# param_2 = obj.findMedian()
```

my comments:
```

from other ppl's solution:

1. cleaner code:
from heapq import *

class MedianFinder:

    def __init__(self):
        self.heaps = [], []

    def addNum(self, num):
        small, large = self.heaps
        heappush(small, -heappushpop(large, num))
        if len(large) < len(small):
            heappush(large, -heappop(small))

    def findMedian(self):
        small, large = self.heaps
        if len(large) > len(small):
            return float(large[0])
        return (large[0] - small[0]) / 2.0
```